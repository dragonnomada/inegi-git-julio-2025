# Práctica 2

Inicializar un repositorio local

```bash
mkdir lab2

cd lab2

git init
```

Inspaccionar la estructura de los archivos

```bash
tree -la
```

```text
.
└── .git
    ├── config
    ├── description
    ├── HEAD
    ├── hooks
    │   ├── applypatch-msg.sample
    │   ├── commit-msg.sample
    │   ├── fsmonitor-watchman.sample
    │   ├── post-update.sample
    │   ├── pre-applypatch.sample
    │   ├── pre-commit.sample
    │   ├── pre-merge-commit.sample
    │   ├── pre-push.sample
    │   ├── pre-rebase.sample
    │   ├── pre-receive.sample
    │   ├── prepare-commit-msg.sample
    │   ├── push-to-checkout.sample
    │   └── update.sample
    ├── info
    │   └── exclude
    ├── objects
    │   ├── info
    │   └── pack
    └── refs
        ├── heads
        └── tags

10 directories, 17 files
```

Inspeccionar el estatus del repositorio

```bash
git status
```

```git
On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

Agregar un archivo

```bash
touch hello.txt
ls -la
```

```text
.
├── .git
└── hello.txt

2 directories, 1 file
```

Inspeccionar nuevamente el estatus del repositorio

```bash
git status
```

```git
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        hello.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Inspeccionar el estatus de los archivos de forma corta

```bash
git status --short
```

> `--short (-s)`

```git
?? hello.txt
```

Agregar el archivo `hello.txt` al *stage*

```bash
git add hello.txt 
```

Volver a inspeccionar el estatus

```bash
git status
```

```git
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   hello.txt
```

Volver a inspeccionar el estatus de forma corta

```bash
git status -s
```

```git
A  hello.txt
```

Inspeccionar la diferencia del *stage*

```bash
git diff --staged
```

```git
diff --git a/hello.txt b/hello.txt
new file mode 100644
index 0000000..e69de29
```

Mostrar solo los nombres de los archivos en la diferencia

```bash
git diff --staged --name-only
```

Confirmar el *stage* (hacer *commit*)

```bash
git commit
```

> Se habre el editor `nano` para escribir el mensaje
> 
> Después de escribir el mensaje se guarda con `CTRL + O` y luego se cierra el editor con `CTRL + X`

```git
[main (root-commit) c6bef99] Archivo hello.txt agregado
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 hello.txt
```

Inspeccionamos el estutus nuevamente

```bash
git status
```

```git
On branch main
nothing to commit, working tree clean
```

Agregar un nuevo archivo

```bash
touch world.txt
```

Inspeccionar el estatus

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        world.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Modificar el archivo `hello.txt`

```bash
nano hello.txt
```

> Se abre el editor `nano`
> 
> Escribe el texto dentro del editor `nano`:

```git
Hola este es un contenido de prueba

Aquí estámos en la tercera línea
```

> Guarda el contenido con `^O` y sal del editor con `^X`

Revsar el estatus

```bash
git status
```

```git
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        world.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Inspeccionamos el estatus de forma breve

```bash
git status -s
```

```git
 M hello.txt
?? world.txt
```

De momento solo queremos agregar el nuevo archivo `world.txt`, sin enviar los cambios sobre `hello.txt`, por lo que lo agregamos

```bash
git add world.txt 
```

Inspeccionamos el estatus que debería mostrar que el archivo `world.txt` fue agregado para *commit*

```bash
git status
```

```git
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   world.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.txt
```

Inspeccionamos en la forma corta

```bash git status -s
 M hello.txt
A  world.txt
```

Mostramos la diferencia de los que está almacenado provisonalmente (**Staging Area**)

```bash
git diff --staged
```

```git
diff --git a/world.txt b/world.txt
new file mode 100644
index 0000000..e69de29
```

Mostramos la diferencia en su forma corta (solo nombre de archivos)

```bash
git diff --staged --name-only
```

```git
world.txt
```

Observamos que solo el archivo `world.txt` está preparado para confirmarse (haerle *commit*), podemos ver esto con la diferencia global y el estatus global que nos indica que `hello.txt` fue modificado pero no está dentro del *stage*.

```bash
git status
```

```git
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   world.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.txt
```

Y la diferencia global

```bash
git diff
```

```git
diff --git a/hello.txt b/hello.txt
index e69de29..a7d68a4 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1,3 @@
+Hola este es un contenido de prueba
+
+Aquí estámos en la tercera línea
```

Confirmamos el *stage* con el mensaje directo

```bash
git commit -m "Archivo world.txt agregado"
```

```git
[main cb79239] Archivo world.txt agregado
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 world.txt
```

Observa que ahora no se abre el editor `nano` para pedirnos el *commit*.

Si revisamos nuevamente el estatus, solo deberíamos encontrar el cambio que se le hizo a `hello.txt` que estaba pendiente.

```bash
git status
```

```git
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   hello.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Si observamos la diferencia, ahí siguen las 3 líneas de texto que agregamos dentro del archivo

```bash
git diff
```

```
diff --git a/hello.txt b/hello.txt
index e69de29..a7d68a4 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1,3 @@
+Hola este es un contenido de prueba
+
+Aquí estámos en la tercera línea
```

Si queremos descartar las modificaciones del archivo `hello.txt` y volver al último estado confirmado, podemos restaturar el archivo a su última confirmación

> **CUIDADO:** Esta acción es irreversible y los cambios temporales que hayamos hecho dentro del archivo se van a perder para siempre, debemos tener mucho cuidado al restaurar un archivo o volver hacia atrás. Git no mostrará ninguna advertencia y hará la restaturación inmediatamente.
>
> Una buena práctica es hacer un reespaldo manual de los archivos modificados antes de hacer la operación, o crear una rama para no perder los cambios antes de volver hacia atrás.

```bash
git restore hello.txt
```

Si inspeccionamos el estatus, ya no habrá nada pendiente, pero los cambios sobre `hello.txt` se perdieron para siempre

```bash
git status
```

```git
On branch main
nothing to commit, working tree clean
```