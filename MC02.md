# MÓDULO 12. PULL REQUESTS (MERGE REQUESTS) 

> CREACIÓN, REVISIÓN Y FUSIÓN DE PULL REQUESTS

## 1. Crear un *Pull Request*

* Se requiere una rama principal (por ejemplo, la rama `A`)
* Se requiren ramas secundarias (por ejemplo, la rama `B` derivada de la rama `A`)
* Se notifica el cierre de la rama `B` (la rama `B` podría actualizarse a la rama `A` antes de publicar sus cambios)
* Cuando el coordinador del repositorio (administrador de la rama principal `A`) determine que es viable la solicitud (procede a hacer la revisión de su trabajo checando que primero esté al día con la rama principal), entonces bloquea notifica a todos que se preparará para mezclar la rama `B` en la rama principal (así los que estén encolados en peticiones pull request serán revocados y tendrán que volver a ponerse al día cuando la fusión esté lista)
* El coordinador procede a fusionar la rama `B` en la rama `A` y resuelve los potenciales conflictos o rechaza la fusión (obliga a `B` a resolver los conflictos primero)
* Si la fusión es aprobada, entonces la rama `A` avanza y el coordinador le avisa a todas las ramas secundarias (desarrolladores) que la rama principal `A` a avanzado integrando los cambios de `B`
* Si la fusión es rechazada, el coordinador notifica el rechazo y procede a integrar otro *Pull Request* pendiente (otra rama secundaria, por ejemplo, `C` también derivada de `A`).

## 2. Revisión del un *Pull Request*

El coordinador de la rama principal (`A`) recibe las solicitudes (dado que nuestra plataforma es interna, podría revisar un grupo de *Teams*).

El coordinador debe revisar los siguientes puntos:

1. Que la rama `B` que solicita fusionarse a la rama `A` tenga sus *commits* reubicados (*rebase*) a la rama principal (`A`). Si no es el caso, entonces, le solicitará a la rama `B` que intente fusionarse con la rama `A` con *merge*, *rebase* o *squash*.
2. Que otras ramas secundarias (`C`, `D`, etc.) que también solicitan fusionarse, tengan menos conflictos de afectar a las otras ramas si se hace la integración, por ejemplo:
   * `B` modifica los archivos `x`, `y` y `z`
   * `C` solo modifica el archivo `x`
   * `D` solo modifica el archivo `y`
   * `E` modifica el archivo `w`
3. El coordinador debe tomar la decisión de quién (qué rama secundaria) se fusionará primero a la rama principal `A`, en este caso podría elegir `E` porque no colisiona con los otros y las demás peticiones son rechazadas hasta que se haga la fusión de la rama `E` a la rama principal `A` y las demás ramas secundarias se acualicen nuevamente.
4. El coordinador debe notificar en todo momento tres mensajes claros:
   * Se recibe la solicitud de fusión: En este momento el coordinador procede a hacer la revisión de la rama secundaria que solicita fusionarse y hace un mapa de conflictos potenciales, si no hay más solicitudes podría procesar la solicitud (jornada 1)
   * Se revisa la solicitud de fusión: En este momento el coordinador se encuentra revisando todas las solicitudes, para determinar qué rama será fusionada primero y les avisa a todas las ramas en petición que esperen (jornada 2)
   * Se acepta o rechaza la fusión: En este momento el coordinador ha decidido aceptar fusionar una única rama a la rama principal y a todas las demás solicitudes las rechaza, entonces notifica quién será fusionado (termina su rama) y quiénes deberán actualizarse una vez que la fusión esté lista (jornada 3)

## 3. Fusionar un *Pull Request*

Para poder fusionar el *pull request* (solicitud de fusión), el coordinador, verificó que la rama secundaria estuviera actualizada a la rama principal, ahora puede proceder a hacer un *merge* directo y borrar la rama secundaria, dando por concluido el trabajo de esa rama o desarrollador (este puede ahora moverse a la siguiente etapa).

Si surge un conflicto no detectado durante la fusión, este debe resolverlo el programador o el coordinador, por lo que antes de cerrar la rama debería garantizar que el proyecto compile y la funcionalidad sea consistente (por ejemplo, pasar las pruebas unitarias).

Si no se logra resolver el conflicto en la jornada 3 (día de aceptación o rechazo de la solicitud fusión o *pull request*), el coordinador podría decidir abortar la fusión y seleccionar otra (si aún hay tiempo) o determinar que todas las solicitudes fueron rechazadas (no se alcanzó a seleccionar aprobar una solicitud), en este caso, ninguna solicitud podría ser rechazada y se crearía una jornada especia para seleccionar la aceptada o mover todas las solicitudes a la siguiente revisión rechazando la original que causó conflicto.

## 4. Calendarización en jornadas de los *Pull Requests*

Entonces, las solicitudes de fusión (*pull request*) se hacen en la jornada 1 (por ejemplo, cada lunes o cada 3 días).

Luego la revisión de las solicitudes de fusión (*pull request*) se hacen en la jornada 2 (por ejemplo, del martes al jueves o al día siguiente de la jornada 1).

Finalmente, la decisión de aceptar o rechazar una solicitud de fusión (*pull request*) se hace en la jornada 3 (por ejemplo, los viernes o al tercer día después de la jornada 2).

Es decir, podemos establecer un calendario para aceptar las solicitudes de fusión al termino de una etapa de desarrollo (por ejemplo cada dos semanas o a fin de mes), en la jornada 1 se reciben las solicitudes (los que lograron terminar sus funcionalidades y quieren cerrar su rama), luego en la jornada 2 se revisan las solicitudes que entraron y se selecciona alguna para fusionarla y las demás solicitudes se rechazan (tienen que volver a mandarlas en la siguiente jornada donde se reciban solicitudes). Finalmente, en la jornada 3, se puede comunicar al ganador para fusionarse (y cerrar su rama), mientras que los otros tendrán que integrar los cambios del ganador para que en la próxima jornada de solicitudes vuelvan a intentarlo, ya con los cambios integrados.

## 5. Estrategias para calendarizar

Supongamos que tenemos una etapa planificada de desarrollo, entonces, esta etapa se debería cubrir en cierto tiempo en la que esté proyectada, por ejemplo, si tenemos 20 días para cubrir la **Etapa 1** (hacer una pantalla de inicio de sesión), podemos planificar los días como:

**Día 1 al 5 (Semana 1)**

Inicio de la etapa, se comienza el desarrollo.

Los desarrolladores comienzan a trabajar sobre sus códigos para llegar al fin de la etapa (Los elementos de la pantalla de inicio de sesión están listos).

**Día 8 (Semana 2)**

Fin de la etapa, se realizan las solicitudes de fusión con la rama principal para comenzar con la siguiente etapa.

El coordinador recibe las solicitudes y los desarrolladores descansan del código (planifican la siguiente etapa).

Si es posible, en este mismo día se comienza a hacer la revisión de las solicitudes, sino se deja para otro día.

**Día 9 (Semana 2)**

Revisión de las solicitudes, se revisa el trabajo por uno o más coordinadores (pueden ser los mismos desarrolladores que ahora asuman el rol de coordinador si falta personal) y proceden a determinar quién cumple los criterios para ser un buen candidato a la fusión:

1. El de menos conflictos (menor trabajo, puede retrasar el proyecto)
2. El de más conflictos (mayor trabajo, puede avanzar el proyecto)

Si es posible ese mismo día se notifica el ganador.

**Día 10 (Semana 2)**

Fusión de la solicitud, se integran los cambios del ganador y se notifica a los rechazados, en esta misma jornada se pudrían recibir nuevas solicitudes si es posible.

**Día 11 (Semana 2)**

Segunda ronda de solicitudes, si es posible este día los desarrolladores integran los cambios del ganador anterior y mandan una nueva propuesta de solicitud de fusión.

**Día 12 (Semana 2)**

Segunda ronda de revisión, en esta segunda ronda se revisan las nuevas solicitudes, habiendo $n - 1$ solicitudes.

**Día 13 (Semana 3)**

Segunda ronda de aceptación/rechazo, en esta segunda ronda se selecciona un nuevo ganador y se rechazan a los demás.

**Día 14 (Semana 4)**

Tercera ronda de solicitudes, en este punto, los conflictos debería ir disminuyendo y si es posible todas las solicitudes pendientes se podrían aceptar (si ya no hay conflictos).

**Días restantes**

Hasta que todas las solicitudes sean procesadas, se podrá cerrar la etapa, si hay muchos desarrolladores no se llegará a tiempo, por lo que lo mejor será mantener equipos cortos de 3 a 5 desarrolladores, para tener un máximo de 4 rondas de solicitudes.

En los días restantes se pueden hacer pruebas y demás.

**IMPORTANTE:** Al planificar un proyecto se debe calcular, cuántas etapas se darán y hacer que estas estapas sean suficientemente cortas para llegar a una funcionalidad, pero suficientemente largas para no perder demasiados días en rondas solicitudes de fusión.

Muchas empresas optan por reducir la jornada del *pull request* a un solo día y así poder atender todas las solicitudes en una misma semana al final de cada etapa, generando un calendario donde 2 semanas son de desarrollo (etapas largas) y una semana es de integración o más cortas como una semana de desarrollo por una semana de integración (etapas cortas).

Lo conveniente es calcular las primeras etapas cortas (ya que habrá muchos conflictos entre los principales archivos) y después planificar etapas más largas (ya que se podrá modulizar el proyecto con una buena base que dejaron las etapas iniciales).