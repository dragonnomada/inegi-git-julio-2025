# MÓDULO 11. REBASE

> INTEGRACIÓN DE CAMBIOS Y USO DE REBASE

## 1. Concepto de *rebase*

> ¿Qué es `git rebase`?

`rebase` es una alternativa a `merge` que **mueve tus commits** y los aplica **encima** de otra rama, creando un historial **más lineal** y fácil de leer.

## 2. Diferencia entre *merge* y *rebase*

| Operación | Resultado                       | Historial         |
|-----------|----------------------------------|-------------------|
| `merge`   | Une ramas con un **commit nuevo** | Historial con ramas y bifurcaciones |
| `rebase`  | **Reescribe commits** como si hubieran sido hechos después de otra rama | Historial **lineal** |

## 3. Funcionalidad del *rebase*

Supongamos que tenemos dos ramas `A` y `B`, donde `A` es una rama principal como `dev/main` y `B` es una rama secundaria como `dev/<nombre>`.

Entonces, en la rama `A` tendremos una línea de tiempo donde se hacen integraciones funcionales de todos los desarrolladores (la rama del desarrollo), y en la rama `B` se hacen nuevas integraciones o correcciones de errores o funcionalidades (la rama del desarrollador).

Así, podemos tener:

```text
A1 -- A2 -- A3 (A)
       \
        B1 -- B2 (B)
```

Es decir, en la rama `A` en el *commit* **A2** se crea la rama para que el desarrollador comience a trabajar en la rama `B` (por ejemplo, al inicio de una etapa de desarrollo).

Luego, la rama `A` recibe otros *commits* de desarrolladores que ya implementaron sus funcionalidades o corrigieron funcionalidades (*commit* **A3**).

Mientas tanto, la rama `B` ha implementado avances como el *commit* **B2**.

Entonces, al hacer **rabase** buscamos avanzar la rama `B` antes de que se intente fusionar a la rama `A`:

```text
A1 -- A2 -- A3 (A)
             \
              B1' -- B2' (B)
```

Lo que significa que avanzamos los *commits* de la rama `A` (principal) a la rama `B` (secundaria) para que se ponga al día, antes de que se le ocurra fusionarse con la rama `A` nuevamente.

A esto lo entenderemos como *desplazamiento* o *actualización* de las subrama.

Ahora, sus *commits* (**B1** y **B2**) son "rebaseados" (reasignados o reubicados) a los *commits* **B1'** y **B2'** para que estén al día respecto a la rama principal (rama `A`). Como si se hubieran creado justo después del *commit* **A3**.

Esto es útil para seguir trabajando sin generar muchas divergencias cuando se intente fusionar de vuelta la rama `B` e integrar sus cambios a la rama `A`.

> ¿Qué pasa si surge un conflicto al hacer *rebase*?

El conflicto se resuelve como en *merge* (corregir los conflictos dentro de los archivos, hacer el *staging*), luego se continua con el *rebase*:

```bash
git rebase --continue
```

Si no hay forma de resolver el conflicto en este momento, se puede cancelar (abortar):

```bash
git rebase --abort
```

Volviendo al estado previo al rebase.

**Nota:** No se hace otro *commit*, se continua con el *rebase*.
